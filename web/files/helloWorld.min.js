/* Created on Tue Oct 29 2013 20:21:32 GMT+0530 (India Standard Time) */
(function() {
  "use strict";

  Neo.KeyCodes = {
    ENTER: 13,
    BACKSPACE: 8,
    UP: 38,
    DOWN: 40,
    LEFT: 37,
    RIGHT: 39
  };

  Neo.getUniqueNumber = (function() {
    var i = 0;

    return function() {
      return i++;
    };
  }());

  Neo.createComponent = function(config) {
    var componentName = config.name;

    if (!(componentName in Neo.Classes)) {
      throw new Error("Unable to find component -> " + componentName);
    }

    Neo.Metrics.addComponent(config);
    var componentId = "c" + Neo.getUniqueNumber();
    var createdAt = Date.now();
    var renderStartTime = Date.now();
    config.componentId = componentId;

    if (config.debugger === true) {
      debugger;
    }

    var component = new Neo.Classes[componentName](config);
    var renderEndTime = Date.now();
    Neo.Metrics.addLog({
      name: config.name,
      createdAt: createdAt,
      renderingTime: renderEndTime - renderStartTime,
      cid: componentId
    });

    return component;
  };

  Neo.ifNull = function(value, defaultValue, typeCheck) {
    if (value == null) {
      if (defaultValue instanceof Error) {
        throw defaultValue;
      } else {
        return defaultValue;
      }
    } else {
      if (typeCheck != null) {
        Neo.typeCheck(value, typeCheck);
      }

      return value;
    }
  };

  Neo.typeCheck = function(value, typeString) {
    var types = typeString.split(",");
    var checkConditions = {
      "string": function(value) {
        return typeof value === "string";
      },
      "number": function(value) {
        return typeof value === "number";
      },
      "function": function(value) {
        return typeof value === "function";
      },
      "array": function(value) {
        return Array.isArray(value);
      },
      "object": function(value) {
        return value != null && value.toString() === "[object Object]";
      },
      "boolean": function(value) {
        return (value === true || value === false);
      },
      "regex": function(value) {
        return value instanceof RegExp;
      },
      "UIComponent": function(value) {
        return value instanceof Neo.Classes.UIComponent;
      },
      "null": function(value) {
        return value === null;
      }
    };

    function isLiteral(value) {
      return value.charAt(0) === "{" && value.charAt(value.length - 1) === "}";
    }

    for (var i = 0; i < types.length; i++) {
      var type = types[i];

      if (isLiteral(type)) {
        // remove the '{' at start and '}' at end, then split on '|'
        var literalParts = type.substr(1, type.length - 2).split("|");

        if (literalParts.indexOf(value) !== -1) {
          return true;
        }
      } else {
        if (!(type in checkConditions)) {
          throw new Error("invalid type -> " + type);
        }

        if (checkConditions[type](value) === true) {
          return true;
        }
      }
    }

    throw new Error("invalid datatype, accepted types are " + typeString);
  };

  Neo.parseQueryString = function() {
    var qs = window.location.search.substr(1);
    var obj = {};

    qs.split("&").forEach(function(part) {
      var parts = part.split("=");
      var key = parts[0];
      var value = parts[1];

      obj[key] = value;
    });

    return obj;
  }

  // http://stackoverflow.com/questions/9399365/deep-extend-like-jquerys-for-nodejs
  Neo.extend = function() {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false,
      toString = Object.prototype.toString,
      hasOwn = Object.prototype.hasOwnProperty,
      push = Array.prototype.push,
      slice = Array.prototype.slice,
      trim = String.prototype.trim,
      indexOf = Array.prototype.indexOf,
      class2type = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regexp",
        "[object Object]": "object"
      },
      jQuery = {
        isFunction: function (obj) {
          return jQuery.type(obj) === "function"
        },
        isArray: Array.isArray ||
        function (obj) {
          return jQuery.type(obj) === "array"
        },
        isWindow: function (obj) {
          return obj != null && obj == obj.window
        },
        isNumeric: function (obj) {
          return !isNaN(parseFloat(obj)) && isFinite(obj)
        },
        type: function (obj) {
          return obj == null ? String(obj) : class2type[toString.call(obj)] || "object"
        },
        isPlainObject: function (obj) {
          if (!obj || jQuery.type(obj) !== "object" || obj.nodeType) {
            return false
          }
          try {
            if (obj.constructor && !hasOwn.call(obj, "constructor") &&
              !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
              return false
            }
          } catch (e) {
            return false
          }
          var key;
          for (key in obj) {}
          return key === undefined || hasOwn.call(obj, key)
        }
      };
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {}
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (i; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : []
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            // WARNING: RECURSION
            target[name] = extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
}());
(function() {
  "use strict";

  Neo.Classes.Metric = function() {
    this.componentHistogram = {};
    this.creationLog = [];
    this.eventLog = [];
  };

  Neo.Classes.Metric.prototype = {
    addComponent: function(component) {
      Neo.typeCheck(component, "object");

      if (!(component.name in this.componentHistogram)) {
        this.componentHistogram[component.name] = 0;
      }

      this.componentHistogram[component.name]++;
    },

    addLog: function(args) {
      this.creationLog.push(args);
    },

    reset: function() {
      this.componentHistogram = {};
    },

    print: function() {
      return JSON.stringify(this, null, "  ");
    },

    addEventLog: function(args) {
      this.eventLog.push(args);
    }
  };

  Neo.Metrics = new Neo.Classes.Metric();
}());
(function() {
  "use strict";

  Neo.Classes.UIComponent = function(config) {
    Neo.ifNull(config, new Error("'config' parameter missing"), "object");
    Neo.ifNull(config.parent, new Error("'parent' missing'"), "object,string");

    this.dom = null;
    this.listenTo = Neo.ifNull(config.listenTo, {}, "object");
    this._canRender = Neo.ifNull(config.canRender, true, "boolean");
    this.listeners = Neo.ifNull(config.listeners, {}, "object");
    this.cname = Neo.ifNull(config.name, new Error("'name' is required"), "string");
    this.parent = Neo.ifNull(config.parent, null);
    this.parentDom = Neo.ifNull(config.parentDom, null);
    this._width = Neo.ifNull(config.width, null, "string,number");
    this._height = Neo.ifNull(config.height, null, "string,number");
    this.cls = Neo.ifNull(config.cls, null, "string");
    this.data = Neo.ifNull(config.data, {});
    this._visible = Neo.ifNull(config.visible, true, "boolean");
    this._notification = null;
    this.children = [];
    this.isHighlighting = false;
    this.hightlightDom = null;
    this.subscribe = Neo.ifNull(config.subscribe, {}, "object");
    this.eventStore = new Neo.Classes.Events(this);
    this.eventRoot = Neo.ifNull(config.eventRoot, this.parent.eventRoot);
    this.models = [];
    this._uiBlocked = false;
    this._uiBlockMask = null;
    this._componentId = Neo.ifNull(config.componentId, null, "string");
    this._tooltip = Neo.ifNull(config.tooltip, null, "object,string");
    this.tooltip = null;
    this.style = Neo.ifNull(config.style, {}, "object");
    this._hint = null;

    if (this.canRender === false) {
      return;
    }

    this.dom = document.createElement("section");
    this.dom._neo = this;

    if (this.cls !== null) {
      this.dom.className = this.cls;
    }

    if (this._componentId) {
      this.dom.dataset.cid = this._componentId;
    }

    this.addClass("comp" + this.cname);

    if (this.parent === "APPLICATION_ROOT" && this.parentDom == null) {
      throw new Error("'parentDom' is missing");
    }

    if (this.parentDom !== null) {
      this.parentDom.appendChild(this.dom);
    }

    var returnValueFromBuildDOM = this.buildDOM();

    if (returnValueFromBuildDOM != null) {
      if (returnValueFromBuildDOM.toString() === "[object Object]") {
        returnValueFromBuildDOM.parent = this;
        returnValueFromBuildDOM.eventRoot = this.eventStore;
        var child = Neo.createComponent(returnValueFromBuildDOM);
        this.dom.appendChild(child.dom);
        this.children.push(child);
      } else {
        this.dom.appendChild(returnValueFromBuildDOM);
        returnValueFromBuildDOM.classList.add("comp" + this.cname + "Inner");
      }
    }

    if (this._width !== null) {
      this.width = this._width;
    }

    if (this._height !== null) {
      this.height = this._height;
    }

    if (this._visible === false) {
      this.visible = false;
    }

    if (this._tooltip !== null) {
      this.tooltip = Neo.createComponent({
        name: "Tooltip",
        component: this._tooltip,
        parent: this
      });
    }

    for (var s in this.style) {
      this.dom.style.setProperty(s, this.style[s]);
    }

    for (var eventName in this.listeners) {
      this.dom.addEventListener(eventName, this.listeners[eventName].bind(this));
    }

    this._setupSubscribers();
  };

  Neo.Classes.UIComponent.prototype = {
    HIGHLIGHT_CLASS: "neoHighlight",

    buildDOM: function() {
      throw new Error("'_buildDOM' must be overridden in the sub class");
    },

    get visible() {
      return this._visible;
    },

    set visible(flag) {
      Neo.typeCheck(flag, "boolean");

      if (flag === true) {
        this.dom.style.display = null;
        this._visible = true;
      } else {
        this.dom.style.display = "none";
        this._visible = false;
      }
    },

    get width() {
      return window.getComputedStyle(this.dom).width;
    },

    set width(value) {
      Neo.typeCheck(value, "string");
      this.dom.childNodes[0].style.width = value;
    },

    get height() {
      return window.getComputedStyle(this.dom).height;
    },

    set height(value) {
      Neo.typeCheck(value, "string");
      this.dom.childNodes[0].style.height = value;
    },

    scrollIntoView: function() {
      this.dom.scrollIntoView();
    },

    set notification(value) {
      Neo.typeCheck(value, "string,number,null");

      if (value === null) {
        this._removeNotification();
      } else {
        if (this._notification === null) {
          var span = document.createElement("span");
          span.textContent = value;
          span.className = "neoNotification";
          this._notification = span;
          this.dom.appendChild(span);
        } else {
          this._notification.textContent = value;
        }
      }
    },

    get notification() {
      if (this._notification !== null) {
        return this._notification.textContent;
      } else {
        return null;
      }
    },

    _removeNotification: function() {
      if (this._notification !== null) {
        this.dom.removeChild(this._notification);
        this._notification = null;
      }
    },

    get highlight() {
      return this.isHighlighting;
    },

    set highlight(value) {
      Neo.typeCheck(value, "boolean");

      if (value === true && this.isHighlighting === false) {
        this._hightlight();
        this.isHighlighting = true;
      } else if (value === false && this.isHighlighting === true) {
        this._removeHightlight();
        this.isHighlighting = false;
      }
    },

    _hightlight: function() {
      var SVG_WIDTH = 70;
      var SVG_HEIGHT = 70;
      var SVG = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(SVG, "svg");
      svg.setAttribute("viewBox", "0 0 100 100");
      svg.setAttribute("class", "neoHighlight");
      this.hightlightDom = svg;

      var xfactor = (parseInt(this.width, 10) / SVG_WIDTH) * 1.1;
      var yfactor = (parseInt(this.height, 10) / SVG_HEIGHT) * 1.1;
      var styleStr = "scaleX(" + xfactor + ") scaleY(" + yfactor + ")";
      svg.style.webkitTransform = styleStr;
      svg.style.transform = styleStr;

      var circlePath = "M34.745,7.183C25.078,12.703,13.516,26.359,8.797,37.13 c\
-13.652,31.134,9.219,54.785,34.77,55.99c15.826,0.742,31.804-2.607,42.207-17.52c\
6.641-9.52,12.918-27.789,7.396-39.713 C85.873,20.155,69.828-5.347,41.802,13.379";
      var path = document.createElementNS(SVG, "path");
      path.setAttribute("d", circlePath);
      path.setAttribute("class", "path");

      svg.appendChild(path);
      this.dom.appendChild(svg);
      path.getBoundingClientRect();
      path.style.strokeDashoffset = "0";
    },

    _removeHightlight: function() {
      this.dom.removeChild(this.hightlightDom);
    },

    addClass: function(str) {
      Neo.typeCheck(str, "string");
      this.dom.classList.add(str);
    },

    removeClass: function(str) {
      Neo.typeCheck(str, "string");
      this.dom.classList.remove(str);
    },

    toggleClass: function(str) {
      Neo.typeCheck(str, "string");
      this.dom.classList.toggle(str);
    },

    hasClass: function(str) {
      Neo.typeCheck(str, "string");
      return this.dom.classList.contains(str);
    },

    remove: function() {
      this.children.forEach(function(child) {
        child.remove();
      });
      this.dom.parentNode.removeChild(this.dom);
    },

    publish: function(eventName) {
      var args = [].slice.call(arguments, 1);

      Neo.Metrics.addEventLog({
        source: this._componentId,
        timestamp: Date.now(),
        event: eventName,
        args: JSON.stringify(args)
      });

      this.eventRoot.publish(eventName, args);
    },

    _setupSubscribers: function() {
      var self = this;

      for (var s in this.subscribe) {
        this.eventRoot.subscribe(s, this.subscribe[s], this);
      }
    },

    registerModel: function(config) {
      config.eventStore = this.eventStore;
      var model = new Neo.Classes.Model(config);
      this.models.push(model);
    },

    trigger: function(eventName, args) {
      var event = document.createEvent('Event');
      event.initEvent(eventName, true, true);
      event.detail = args;
      this.dom.dispatchEvent(event);
    },

    get blockUI() {
      return this._uiBlocked;
    },

    set blockUI(value) {
      Neo.typeCheck(value, "boolean");
      var eventBlackList = ["click", "keyup", "keydown", "keypress", "mouseover"];

      if (value === true && !this._uiBlocked) {
        var mask = document.createElement("div");
        mask.className = "uiBlockMask";
        mask.tabIndex = "-1";
        mask.focus();
        eventBlackList.forEach(function(event) {
          mask.addEventListener(event, function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
        });
        this.dom.appendChild(mask);
        this._uiBlockMask = mask;
        this._uiBlocked = true;
      } else if (value === false && this._uiBlocked) {
        this.dom.removeChild(this._uiBlockMask);
        this._uiBlockMask = null;
        this._uiBlocked = false;
      }
    },

    createDialog: function(config) {
      config.name = "Dialog";
      config.parentDom = this.dom;
      config.parent = this;
      config.root = this;
      return Neo.createComponent(config);
    },

    alert: function(config) {
      Neo.typeCheck(config, "string,object");

      var DEFAULT_TITLE = "Application";
      var text, title, callback;

      if (typeof config === "string") {
        text = config;
        title = DEFAULT_TITLE;
      } else {
        text = Neo.ifNull(config.text, new Error("Alert 'text' missing"), "string");
        title = Neo.ifNull(config.title, DEFAULT_TITLE, "string");
        callback = Neo.ifNull(config.callback, function() {}, "function");
      }

      var dialog = this.createDialog({
        name: "Dialog",
        cls: "neoAlert",
        title: title,
        body: {
          name: "Layout",
          items: [{
            cls: "neoAlertText",
            component: {
              name: "Label",
              text: text
            }
          }, {
            cls: "neoAlertOk",
            component: {
              name: "Button",
              text: "OK",
              listeners: {
                click: function() {
                  dialog.close();
                }
              }
            }
          }]
        },
        afterClose: callback
      });

      dialog.open();
    },

    showTooltip: function(callback) {
      this.tooltip.show(callback);
    },

    hideTooltip: function(callback) {
      this.tooltip.hide(callback);
    },

    set hint(value) {
      Neo.typeCheck(value, "string,object,null");

      var removeHint = function() {
        if (this._hint !== null) {
          this._hint.remove();
          this._hint = null;
        }
      }.bind(this);

      if (value === null) {
        removeHint();
      } else {
        removeHint();
        this._hint = Neo.createComponent({
          name: "Tooltip",
          component: value,
          parent: this,
          autoShowHide: false
        });
        this._hint.show();
      }
    }
  };

  // http://ejohn.org/blog/javascript-getters-and-setters/
  function copy(a,b) {
    for ( var i in b ) {
        var g = b.__lookupGetter__(i), s = b.__lookupSetter__(i);

        if ( g || s ) {
            if ( g )
                a.__defineGetter__(i, g);
            if ( s )
                a.__defineSetter__(i, s);
         } else
             a[i] = b[i];
    }
    return a;
  }

  function extend(parentClass, properties) {
    if ("extend" in properties) {
      throw new Error("do not use 'extend' as a property, already in use by framework");
    }

    function childClass() {
      if ("init" in properties) {
        properties.init.apply(this, arguments);
      }
    };

    childClass.prototype = Object.create(parentClass.prototype);

    copy(childClass.prototype, properties);

    childClass.extend = extend.bind(null, childClass);

    return childClass;
  }

  Neo.Classes.UIComponent.extend = extend.bind(null, Neo.Classes.UIComponent);
}());
(function() {
  "use strict";

  Neo.Classes.EventProcessor = function(config) {
    Neo.typeCheck(config.eventString, "string");
    Neo.typeCheck(config.eventHandler, "function");
    Neo.typeCheck(config.deleteCallback, "function");

    this.context = config.context;
    this.eventString = config.eventString;
    this.eventHandler = config.eventHandler;
    this.deleteCallback = config.deleteCallback;
    this.type = this._detectType();
    this.eventNames = this._parseEventNames();
    this.eventMap = {};

    this.eventNames.forEach(function(eventName) {
      this.eventMap[eventName] = false;
    }.bind(this));
  }

  Neo.Classes.EventProcessor.prototype = {
    SIMPLE: "SIMPLE",
    ONCE: "ONCE",
    AND: "AND",
    OR: "OR",

    raise: function(eventName, data) {
      switch (this.type) {
        case this.SIMPLE:
        case this.OR:
          this.eventHandler.apply(this.context, data);
          break;
        case this.ONCE:
          this.deleteCallback();
          this.eventHandler.apply(this.context, data);
          break;
        case this.AND:
          this.eventMap[eventName] = true;

          var allAndEventsRaised = true;
          for (var i in this.eventMap) {
            if (this.eventMap[i] === false) {
              allAndEventsRaised = false;
              break;
            }
          }

          if (allAndEventsRaised) {
            for (var j in this.eventMap) {
              this.eventMap[j] = false;
            }

            this.eventHandler.apply(this.context, data);
          }
          break;
      }
    },

    _detectType: function() {
      if (this.eventString.substr(0, 5) === "ONCE ") {
        return this.ONCE;
      } else if (/\bAND\b/.test(this.eventString)) {
        return this.AND;
      } else if (/\bOR\b/.test(this.eventString)) {
        return this.OR;
      } else {
        return this.SIMPLE;
      }
    },

    _parseEventNames: function() {
      function trim(str) {
        return str.trim();
      }

      switch (this.type) {
        case this.ONCE:
          return [this.eventString.substr(5)];
          break;
        case this.AND:
          return this.eventString.split(/\bAND\b/).map(trim);
          break;
        case this.OR:
          return this.eventString.split(/\bOR\b/).map(trim);
          break;
        case this.SIMPLE:
          return [this.eventString];
          break;
      }
    }
  };
}());
(function() {
  "use strict";

  Neo.Classes.Model = function(config) {
    this._attributes = Neo.ifNull(config.attributes, {}, "object");;
    this._listeners = Neo.ifNull(config.listeners, {}, "object");
    this._subscribe = Neo.ifNull(config.subscribe, {}, "object");
    this._validation = Neo.ifNull(config.validation, this.VALIDATION, "function");
    this._eventStore = Neo.ifNull(config.eventStore,
                                  new Error("'eventStore' missing for model"));

    Object.seal(this._attributes);
    this._defineGettersAndSetters();
    this._setupSubscribers();
  };

  Neo.Classes.Model.prototype = {
    VALIDATION: function() {
      return true;
    },

    get valid() {
      return this._validation(this._attributes);
    },

    get attributes() {
      return this._attributes;
    },

    set attributes(value) {
      Neo.typeCheck(value, "object");

      if (this._validation(Neo.extend({}, this._attributes, value))) {
        for (var i in value) {
          this._attributes[i] = value[i];
        }

        this.trigger("change", value);
      } else {
        throw new Error("validation error");
      }
    },

    _defineGettersAndSetters: function() {
      Object.keys(this._attributes).forEach(function(key) {
        Object.defineProperty(this, key, {
          get: function() {
            return this._attributes[key];
          },

          set: function(value) {
            var obj = {};

            obj[key] = value;
            this.attributes = obj;
          }
        });
      }.bind(this));
    },

    trigger: function(event) {
      var args = [].slice.call(arguments, 1);

      if (event in this._listeners) {
        this._listeners[event].apply(null, args);
      }
    },

    _setupSubscribers: function() {
      var self = this;

      for (var s in this._subscribe) {
        this._eventStore.subscribe(s, this._subscribe[s], this);
      }
    },

    publish: function(eventName) {
      var args = [].slice.call(arguments, 1);

      this._eventStore.publish(eventName, args);
    }
  };
}());
(function() {
  "use strict";

  Neo.Classes.Events = function(owner) {
    this.owner = owner;
    this.registry = {};
  };

  Neo.Classes.Events.prototype = {
    publish: function(eventName, args) {
      if (eventName in this.registry) {
        this.registry[eventName].forEach(function(eObj) {
          eObj.raise(eventName, args);
        }.bind(this));
      }
    },

    subscribe: function(event, callback, context) {
      var self = this;

      var eventProcess = new Neo.Classes.EventProcessor({
        eventString: event,
        eventHandler: callback,
        context: context,
        deleteCallback: function() {
          eventProcess.eventNames.forEach(function(event) {
            var index = self.registry[event].indexOf(eventProcess);
            delete self.registry[event][index];
          });
        }
      });

      eventProcess.eventNames.forEach(function(event) {
        if (!(event in self.registry)) {
          self.registry[event] = [];
        }

        self.registry[event].push(eventProcess);
      });
    }
  };
}());
(function() {
  "use strict";

  Neo.Classes.Tooltip = Neo.Classes.UIComponent.extend({
    HIDE_TIMEOUT: 250,
    ORIENT_TOP: "top",
    ORIENT_BOTTOM: "bottom",
    ORIENT_LEFT: "left",
    ORIENT_RIGHT: "right",

    init: function(config) {
      var e = new Error("'component' missing from tooltip");
      this.component = Neo.ifNull(config.component || config.text, e, "object,string");
      this.autoShowHide = Neo.ifNull(config.autoShowHide, true, "boolean");
      this.hideTimer = null;
      config.parentDom = config.parent.dom;
      config.visible = false;

      Neo.Classes.UIComponent.call(this, config);

      if (this.autoShowHide) {
        this.parent.dom.addEventListener("mouseover", function() {
          clearInterval(this.hideTimer);
          this.show();
        }.bind(this));

        this.parent.dom.addEventListener("mouseout", function() {
          this.hideTimer = setTimeout(function() {
            this.hide();
          }.bind(this), this.HIDE_TIMEOUT);
        }.bind(this));
      }
    },

    buildDOM: function() {
      var component;

      var arrow = document.createElement("div");
      arrow.className = "tooltipArrow";
      this.dom.appendChild(arrow);

      if (typeof this.component === "string") {
        component = {
          name: "Label",
          text: this.component
        };
      } else {
        component = this.component;
      }

      component.parent = this;
      component.parentDom = this.dom;
      Neo.createComponent(component);
    },

    show: function() {
      if (!this.visible) {
        this.visible = true;
        var tooltipRect = this.dom.getBoundingClientRect();
        var compRect = this.parent.dom.getBoundingClientRect();
        var y = "-" + (tooltipRect.height + 10) + "px";

        if (compRect.top > tooltipRect.height) {
          this.dom.style.top = y;
          this.addClass(this.ORIENT_TOP);
        } else {
          this.dom.style.bottom = y;
          this.addClass(this.ORIENT_BOTTOM);
        }

        if (compRect.right > tooltipRect.width) {
          this.addClass(this.ORIENT_LEFT);
        } else {
          this.addClass(this.ORIENT_RIGHT);
        }
      }
    },

    hide: function() {
      if (this.visible) {
        this.visible = false;
        this.removeClass(this.ORIENT_TOP);
        this.removeClass(this.ORIENT_BOTTOM);
      }
    }
  });
}());
(function() {
  "use strict";

  Neo.Classes.Label = Neo.Classes.UIComponent.extend({
    NO_TEXT: "NO TEXT",

    init: function(config) {
      this._text = Neo.ifNull(config.text, this.NO_TEXT, "string");

      Neo.Classes.UIComponent.call(this, config);
    },

    buildDOM: function() {
      var dom = document.createElement("label");

      dom.textContent = this._text;

      return dom;
    },

    get text() {
      return this._text;
    },

    set text(value) {
      Neo.typeCheck(value, "string,number");

      this._text = value;
      this.dom.childNodes[0].textContent = this._text;
    },

    clear: function() {
      this.text = "";
    }
  });
}());
(function() {
  "use strict";

  Neo.Classes.HelloWorld = Neo.Classes.UIComponent.extend({
    init: function(config) {
      Neo.Classes.UIComponent.call(this, config);
    },

    buildDOM: function() {
      return {
        name: "Label",
        text: "Hello World"
      };
    }
  });
}());